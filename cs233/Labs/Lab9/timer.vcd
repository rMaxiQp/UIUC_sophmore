$date
	Wed Oct 25 16:11:47 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module timer_test $end
$var wire 1 ! TimerAddress $end
$var wire 1 " TimerInterrupt $end
$var wire 32 # cycle [31:0] $end
$var reg 1 $ MemRead $end
$var reg 1 % MemWrite $end
$var reg 32 & address [31:0] $end
$var reg 1 ' clock $end
$var reg 32 ( data [31:0] $end
$var reg 1 ) reset $end
$scope module t $end
$var wire 32 * D_CC [31:0] $end
$var wire 1 + MemRead $end
$var wire 1 , MemWrite $end
$var wire 32 - Q_CC [31:0] $end
$var wire 32 . Q_IC [31:0] $end
$var wire 1 ! TimerAddress $end
$var wire 1 " TimerInterrupt $end
$var wire 1 / ackCheck $end
$var wire 1 0 acknowledge $end
$var wire 1 1 addrCheck $end
$var wire 32 2 address [31:0] $end
$var wire 1 3 clock $end
$var wire 32 4 cycle [31:0] $end
$var wire 32 5 data [31:0] $end
$var wire 1 6 il_enable $end
$var wire 1 7 il_reset $end
$var wire 1 8 reset $end
$var wire 1 9 timerRead $end
$var wire 1 : timerWrite $end
$scope module tc $end
$var wire 1 9 control $end
$var wire 32 ; d [31:0] $end
$var wire 32 < o [31:0] $end
$upscope $end
$scope module il $end
$var wire 1 3 clk $end
$var wire 1 = d $end
$var wire 1 6 enable $end
$var wire 1 7 reset $end
$var reg 1 > q $end
$upscope $end
$scope module ic $end
$var wire 1 3 clk $end
$var wire 32 ? d [31:0] $end
$var wire 1 : enable $end
$var wire 1 8 reset $end
$var reg 32 @ q [31:0] $end
$upscope $end
$scope module cc $end
$var wire 1 3 clk $end
$var wire 32 A d [31:0] $end
$var wire 1 B enable $end
$var wire 1 8 reset $end
$var reg 32 C q [31:0] $end
$upscope $end
$scope module plus $end
$var wire 3 D control [2:0] $end
$var wire 32 E inA [31:0] $end
$var wire 32 F inB [31:0] $end
$var wire 1 G negative $end
$var wire 32 H out [31:0] $end
$var wire 1 I zero $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xI
bx H
xG
b1 F
bx E
b0 D
bx C
1B
bx A
bx @
b0 ?
x>
1=
bz <
bx ;
0:
09
18
17
x6
b0 5
bz 4
03
b0 2
01
00
0/
bx .
bx -
0,
0+
bx *
1)
b0 (
0'
b0 &
0%
0$
bz #
x"
0!
$end
#5
0G
0I
b1 *
b1 A
b1 H
0>
0"
b11111111111111111111111111111111 @
06
b11111111111111111111111111111111 .
b0 C
b0 -
b0 ;
b0 E
1'
13
#10
b0 #
b0 4
b0 <
19
1!
07
0'
03
1$
1+
b11111111111111110000000000011100 &
b11111111111111110000000000011100 2
11
0)
08
#15
b10 *
b10 A
b10 H
b1 #
b1 4
b1 <
b1 C
b1 -
b1 ;
b1 E
1'
13
#20
0'
03
#25
b11 *
b11 A
b11 H
b10 #
b10 4
b10 <
b10 C
b10 -
b10 ;
b10 E
1'
13
#30
0'
03
#35
b100 *
b100 A
b100 H
b11 #
b11 4
b11 <
b11 C
b11 -
b11 ;
b11 E
1'
13
#40
0'
03
#45
b101 *
b101 A
b101 H
b100 #
b100 4
b100 <
b100 C
b100 -
b100 ;
b100 E
1'
13
#50
bz #
bz 4
bz <
1:
09
0'
03
1%
1,
0$
0+
b110 (
b110 5
b110 ?
#55
b110 *
b110 A
b110 H
b101 C
b101 -
b101 ;
b101 E
b110 @
b110 .
1'
13
#60
b101 #
b101 4
b101 <
0:
19
0'
03
0%
0,
1$
1+
#65
b111 *
b111 A
b111 H
b110 #
b110 4
b110 <
b110 C
16
b110 -
b110 ;
b110 E
1'
13
#70
0'
03
#75
b1000 *
b1000 A
b1000 H
b111 #
b111 4
b111 <
b111 C
06
b111 -
b111 ;
b111 E
1>
1"
1'
13
#80
0'
03
#85
b1001 *
b1001 A
b1001 H
b1000 #
b1000 4
b1000 <
b1000 C
b1000 -
b1000 ;
b1000 E
1'
13
#90
0'
03
#95
b1010 *
b1010 A
b1010 H
b1001 #
b1001 4
b1001 <
b1001 C
b1001 -
b1001 ;
b1001 E
1'
13
#100
bz #
bz 4
bz <
17
09
10
0'
03
1%
1,
0$
0+
b11111111111111110000000001101100 &
b11111111111111110000000001101100 2
01
1/
#105
b1011 *
b1011 A
b1011 H
0>
0"
b1010 C
b1010 -
b1010 ;
b1010 E
1'
13
#110
0'
03
