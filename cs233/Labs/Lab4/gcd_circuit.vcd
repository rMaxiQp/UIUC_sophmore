$date
	Tue Sep 19 22:25:13 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module gcd_circuit_test $end
$var wire 32 ! out [31:0] $end
$var wire 1 " x_lt_y $end
$var wire 1 # x_ne_y $end
$var reg 32 $ X [31:0] $end
$var reg 32 % Y [31:0] $end
$var reg 1 & clock $end
$var reg 1 ' output_en $end
$var reg 1 ( reset $end
$var reg 1 ) x_en $end
$var reg 1 * x_sel $end
$var reg 1 + y_en $end
$var reg 1 , y_sel $end
$scope module circuit $end
$var wire 32 - X [31:0] $end
$var wire 32 . Y [31:0] $end
$var wire 1 / clock $end
$var wire 32 0 out [31:0] $end
$var wire 1 1 output_en $end
$var wire 1 2 reset $end
$var wire 32 3 w1 [31:0] $end
$var wire 32 4 w2 [31:0] $end
$var wire 32 5 w_tmpX [31:0] $end
$var wire 32 6 w_tmpY [31:0] $end
$var wire 32 7 w_x [31:0] $end
$var wire 32 8 w_y [31:0] $end
$var wire 1 9 x_en $end
$var wire 1 " x_lt_y $end
$var wire 1 # x_ne_y $end
$var wire 1 : x_sel $end
$var wire 1 ; y_en $end
$var wire 1 < y_sel $end
$scope module m1 $end
$var wire 32 = A [31:0] $end
$var wire 32 > B [31:0] $end
$var wire 32 ? out [31:0] $end
$var wire 1 : sel $end
$var wire 32 @ temp1 [31:0] $end
$var wire 32 A temp2 [31:0] $end
$upscope $end
$scope module m2 $end
$var wire 32 B A [31:0] $end
$var wire 32 C B [31:0] $end
$var wire 32 D out [31:0] $end
$var wire 1 < sel $end
$var wire 32 E temp1 [31:0] $end
$var wire 32 F temp2 [31:0] $end
$upscope $end
$scope module r1 $end
$var wire 1 / clk $end
$var wire 32 G d [31:0] $end
$var wire 1 9 enable $end
$var wire 1 2 reset $end
$var reg 32 H q [31:0] $end
$upscope $end
$scope module r2 $end
$var wire 1 / clk $end
$var wire 32 I d [31:0] $end
$var wire 1 ; enable $end
$var wire 1 2 reset $end
$var reg 32 J q [31:0] $end
$upscope $end
$scope module s1 $end
$var wire 32 K A [31:0] $end
$var wire 32 L B [31:0] $end
$var wire 32 M out [31:0] $end
$upscope $end
$scope module s2 $end
$var wire 32 N A [31:0] $end
$var wire 32 O B [31:0] $end
$var wire 32 P out [31:0] $end
$upscope $end
$scope module c1 $end
$var wire 32 Q A [31:0] $end
$var wire 32 R B [31:0] $end
$var wire 1 " lt $end
$var wire 1 # ne $end
$upscope $end
$scope module r3 $end
$var wire 1 / clk $end
$var wire 32 S d [31:0] $end
$var wire 1 1 enable $end
$var wire 1 2 reset $end
$var reg 32 T q [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 T
b0 S
b0 R
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b0 F
b0 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
0<
0;
0:
09
b0 8
b0 7
b0 6
b0 5
b0 4
b0 3
12
01
b0 0
0/
b0 .
b0 -
0,
0+
0*
0)
1(
0'
0&
b0 %
b0 $
0#
0"
b0 !
$end
#1
0(
02
1&
1/
#2
0&
0/
#3
1&
1/
#4
b110 6
b110 D
b110 I
b1001 5
b1001 ?
b1001 G
b110 E
b1001 @
0&
0/
1+
1;
1)
19
b110 %
b110 .
b110 B
b1001 $
b1001 -
b1001 =
#5
b1001 H
b1001 7
b1001 K
b1001 O
b1001 Q
b1001 S
b110 J
b11 3
b11 >
b11 M
b11111111111111111111111111111101 4
b11111111111111111111111111111101 C
b11111111111111111111111111111101 P
0"
1#
b110 8
b110 L
b110 N
b110 R
1&
1/
#6
0&
0/
0+
0;
0)
09
#7
1&
1/
#8
0&
0/
1'
11
#9
b1001 T
b1001 !
b1001 0
1&
1/
#10
0&
0/
0'
01
#11
1&
1/
#12
b11 5
b11 ?
b11 G
b0 @
b11 A
0&
0/
1*
1:
1)
19
#13
b11111111111111111111111111111101 5
b11111111111111111111111111111101 ?
b11111111111111111111111111111101 G
b11111111111111111111111111111101 A
b11 H
b11111111111111111111111111111101 3
b11111111111111111111111111111101 >
b11111111111111111111111111111101 M
b11 4
b11 C
b11 P
1"
b11 7
b11 K
b11 O
b11 Q
b11 S
1&
1/
#14
b1001 5
b1001 ?
b1001 G
b1001 @
b0 A
0&
0/
0*
0:
0)
09
#15
1&
1/
#16
0&
0/
1'
11
#17
b11 T
b11 !
b11 0
1&
1/
#18
0&
0/
0'
01
#19
1&
1/
#20
0&
0/
#21
1&
1/
#22
0&
0/
